# Fastfile
require 'fileutils'
require 'json'
require 'net/http'

default_platform(:ios)

platform :ios do
  lane :build_framework do |options|
    # 1. 接收并解析 JSON 格式密钥，获取所有 vfp 字段（仅这一步在循环外）
    secret_json_str = options[:build_users]
    unless secret_json_str
      UI.user_error!("❌ 请传入 JSON 格式密钥：fastlane build_framework build_users:\"{你的JSON字符串}\"")
    end

    # 解析 JSON 并提取所有 vfp 字段
    begin
      secret_json = JSON.parse(secret_json_str)
      unless secret_json.key?("data") && secret_json["data"].is_a?(Array) && !secret_json["data"].empty?
        UI.user_error!("❌ JSON 格式错误：缺少有效的 data 数组")
      end

      # 收集所有有效的 vfp 字段和对应的用户信息
      user_data_list = secret_json["data"].each_with_index.map do |item, index|
        vfp = item["vfp"]&.to_s&.strip
        account_id = item["id"]&.to_s&.strip
        account_name = item["accountName"]&.to_s&.strip
        channel = item["channel"]&.to_s&.strip
        
        unless vfp && !vfp.empty?
          UI.user_error!("❌ JSON 格式错误：data 数组第 #{index + 1} 个元素缺少有效的 vfp 字段")
        end
        unless account_id && !account_id.empty?
          UI.user_error!("❌ JSON 格式错误：data 数组第 #{index + 1} 个元素缺少有效的 id 字段")
        end
        
        {
          vfp: vfp,
          account_id: account_id,
          account_name: account_name || "未知用户",
          channel: channel || "default_channel"
        }
      end

      UI.success("✅ 成功解析 JSON 密钥，共获取 #{user_data_list.size} 个用户数据，开始循环处理...")
    rescue JSON::ParserError => e
      UI.user_error!("❌ JSON 解析失败：#{e.message}")
    end

    # 基础路径（循环外定义公共根目录）
    base_work_dir = "./build_multi_vfp_#{Time.now.strftime('%Y%m%d_%H%M%S')}"
    FileUtils.mkdir_p(base_work_dir)
    UI.message("📂 所有构建的根目录：#{base_work_dir}")

    # 2. 遍历每个用户数据，将步骤2-7全部纳入循环
    user_data_list.each_with_index do |user_data, index|
      current_vfp = user_data[:vfp]
      UI.message("\n\n==================================================")
      UI.message("🔄 开始处理第 #{index + 1}/#{user_data_list.size} 个用户：#{user_data[:account_name]}（#{current_vfp[0, 6]}...）")
      UI.message("==================================================\n")

      # --------------------------
      # 步骤2：当前 vfp 的路径配置（循环内定义，完全隔离）
      # --------------------------
      # 当前 vfp 的独立工作目录（所有文件均在此目录，避免交叉污染）
      current_work_dir = "#{base_work_dir}/vfp_#{index + 1}"
      FileUtils.mkdir_p(current_work_dir)

      # 当前 vfp 的密钥文件路径（独立路径，避免覆盖）
      secret_file_path = "../HearonTestSDK/HearonTestSDK/SecretKey.swift"
      
      # 当前 vfp 的编译输出目录
      current_build_output = "#{current_work_dir}/framework"
      FileUtils.mkdir_p(current_build_output)
      
      # 当前 vfp 的最终 Framework 路径
      current_final_framework = "#{current_build_output}/HearonTestSDK.framework"
      
      # 项目路径（固定，可共享）
      project_path = "../HearonTestSDK.xcodeproj"
      unless File.exist?(project_path)
        UI.error("❌ 项目文件不存在，跳过当前用户处理")
        next
      end

      begin
        # --------------------------
        # 步骤3：生成当前 vfp 的密钥文件（循环内执行）
        # --------------------------
        UI.message("🔑 生成当前 vfp 的密钥文件...")
        secret_content = <<~SWIFT
          // 自动生成，对应第 #{index + 1} 个用户：#{user_data[:account_name]}
          internal let CustomFrameworkSecretKey = "#{current_vfp}"
        SWIFT
        File.write(secret_file_path, secret_content)
        UI.success("✅ 密钥文件生成：#{secret_file_path}")

        # --------------------------
        # 步骤4：清理当前 vfp 的构建缓存（循环内执行，避免残留）
        # --------------------------
        UI.message("🧹 清理当前 vfp 的构建缓存...")
        clean_command = <<~CMD
          xcodebuild clean \
          -project "#{project_path}" \
          -scheme HearonTestSDK \
          -configuration Debug
        CMD
        # 执行清理命令，输出日志到当前工作目录
        system("#{clean_command} > #{current_work_dir}/clean_log.txt 2>&1")
        UI.success("✅ 清理完成（日志：#{current_work_dir}/clean_log.txt）")

        # --------------------------
        # 步骤5：编译当前 vfp 的真机Framework（循环内执行，完全独立）
        # --------------------------
        UI.message("🔨 开始编译当前 vfp 的 Framework...")
        derived_framework_path = ""

        # 方案1：优先使用 archive（输出到当前工作目录）
        archive_path = "#{current_work_dir}/HearonTestSDK.xcarchive"
        archive_command = <<~CMD
          xcodebuild archive \
          -project "#{project_path}" \
          -scheme HearonTestSDK \
          -configuration Release \
          -sdk iphoneos \
          -archivePath "#{archive_path}" \
          SKIP_INSTALL=NO \
          BUILD_LIBRARY_FOR_DISTRIBUTION=YES \
          GCC_PREPROCESSOR_DEFINITIONS="SECRET_KEY_FILE=#{secret_file_path}"
        CMD
        # 执行 archive 命令，日志输出到当前工作目录
        system("#{archive_command} > #{current_work_dir}/archive_log.txt 2>&1")

        # 检查 archive 产物
        archive_framework_path = "#{archive_path}/Products/Library/Frameworks/HearonTestSDK.framework"
        if File.exist?(archive_framework_path)
          UI.success("✅ Archive 编译成功")
          derived_framework_path = archive_framework_path
        else
          # 方案2：回退到 build 命令（输出到当前工作目录）
          UI.message("📦 archive 产物未找到，尝试 build 命令...")
          derived_data_path = "#{current_work_dir}/DerivedData"
          build_command = <<~CMD
            xcodebuild build \
            -project "#{project_path}" \
            -scheme HearonTestSDK \
            -configuration Debug \
            -sdk iphoneos \
            -arch arm64 \
            -derivedDataPath "#{derived_data_path}" \
            ONLY_ACTIVE_ARCH=NO \
            CODE_SIGNING_ALLOWED=NO \
            GCC_PREPROCESSOR_DEFINITIONS="SECRET_KEY_FILE=#{secret_file_path}"
          CMD
          system("#{build_command} > #{current_work_dir}/build_log.txt 2>&1")

          # 检查 build 产物
          derived_framework_path = "#{derived_data_path}/Build/Products/Debug-iphoneos/HearonTestSDK.framework"
          unless File.exist?(derived_framework_path)
            raise "build 产物未找到（日志：#{current_work_dir}/build_log.txt）"
          end
          UI.success("✅ Build 编译成功")
        end

        # 复制当前 vfp 的 Framework 到输出目录
        FileUtils.rm_rf(current_final_framework) if File.exist?(current_final_framework)
        FileUtils.cp_r(derived_framework_path, current_final_framework)
        UI.success("📦 第 #{index + 1} 个 Framework 已保存到：#{current_final_framework}")

        # 验证二进制文件
        framework_binary = "#{current_final_framework}/HearonTestSDK"
        unless File.exist?(framework_binary)
          raise "Framework 内无二进制文件：#{framework_binary}"
        end

        # 输出架构信息
        arch_info = `lipo -info #{framework_binary} 2>&1`.strip
        if arch_info.include?("arm64")
          UI.success("📊 架构信息：#{arch_info}")
        else
          UI.important("⚠️ 架构信息异常：#{arch_info}")
        end

        # --------------------------
        # 步骤6：压缩 Framework 并上传
        # --------------------------
        UI.message("📦 开始压缩 Framework...")
        
        # 压缩文件路径
        zip_file_path = "#{current_work_dir}/framework/HearonTestSDK.zip"
        
        UI.message("压缩路径: #{zip_file_path}")

        # 修复压缩命令：不使用 cd，直接指定完整路径
        zip_command = "ditto -c -k --sequesterRsrc --keepParent \"#{current_final_framework}\" \"#{zip_file_path}\""
        UI.message("压缩命令: #{zip_command}")

        zip_success = system("#{zip_command} > \"#{current_work_dir}/zip_log.txt\" 2>&1")
        
        unless zip_success && File.exist?(zip_file_path)
          # 读取压缩日志以便更好的错误信息
          zip_log_content = File.exist?("#{current_work_dir}/zip_log.txt") ? File.read("#{current_work_dir}/zip_log.txt") : "无日志文件"
          raise "Framework 压缩失败（日志：#{zip_log_content}）"
        end
        
        zip_file_size = File.size(zip_file_path)
        UI.success("✅ 压缩完成：#{zip_file_path} (#{zip_file_size / 1024 / 1024} MB)")

        # # 上传文件
        UI.message("🌐 开始上传文件到服务器...")
        upload_result = upload_file(zip_file_path)
        
        unless upload_result && upload_result["code"] == 0 && upload_result["data"]["list"][0]["file_id"] && upload_result["data"]["list"][0]["upload_file_url"]
          raise "文件上传失败：#{upload_result}"
        end
        
        file_id = upload_result["data"]["list"][0]["file_id"]
        file_url = upload_result["data"]["list"][0]["upload_file_url"]
        UI.success("✅ 文件上传成功")
        UI.message("File ID: #{file_id}")
        UI.message("File URL: #{file_url}")

        # --------------------------
        # 步骤7：调用保存关系接口
        # --------------------------
        UI.message("💾 开始保存包关系信息...")
        
        save_params = {
          account_id: user_data[:account_id],
          account_name: user_data[:account_name],
          pkg_id: file_id,
          pkg_url: file_url,
          pkg_version: "1.0", # 固定版本号
          channel: user_data[:channel]
        }
        UI.message("调用参数：#{save_params}")
        save_result = save_account_pkg_relation(save_params)
        
        if save_result && save_result["data"]["succTag"]
          UI.success("✅ 包关系保存成功")
        else
          error_msg = save_result ? save_result["data"]["msg"] || save_result.to_s : "未知错误"
          UI.error("❌ 包关系保存失败：#{error_msg}")
        end

      rescue => e
        # 单个用户处理失败，记录错误后继续下一个
        UI.error("❌ 第 #{index + 1} 个用户处理失败：#{e.message}")
        UI.error("Backtrace: #{e.backtrace.join("\n")}") if e.backtrace
        next
      ensure
        # 清理当前 vfp 的临时密钥文件（无论成功失败）
        File.delete(secret_file_path) if File.exist?(secret_file_path)
      end

      UI.success("\n✅ 第 #{index + 1} 个用户 #{user_data[:account_name]} 处理完成")
    end

    # 所有用户处理完成后汇总
    UI.success("\n🎉 所有用户处理完毕！")
    UI.success("📁 所有产物路径：")
    user_data_list.each_with_index do |user_data, index|
      safe_name = user_data[:account_name].gsub(/[^\w]/, '_')
      UI.message("   - 第 #{index + 1} 个 (#{user_data[:account_name]}): #{base_work_dir}/vfp_#{index + 1}_#{safe_name}/framework/HearonTestSDK.framework")
    end
  end

  # 上传文件方法
  def upload_file(file_path)
    # 请替换为您的实际上传接口 URL
    upload_url = "https://sit-soc.uim-solution.com/cvn/app/upload_file"
    
    uri = URI.parse(upload_url)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = (uri.scheme == 'https')

    # 创建 multipart 请求
    boundary = "----WebKitFormBoundary#{Time.now.to_i}"
    
    # 构建 multipart 请求体
    post_body = []
    post_body << "--#{boundary}\r\n"
    post_body << "Content-Disposition: form-data; name=\"file\"; filename=\"#{File.basename(file_path)}\"\r\n"
    post_body << "Content-Type: application/zip\r\n\r\n"
    post_body << File.binread(file_path)
    post_body << "\r\n--#{boundary}--\r\n"
    
    request = Net::HTTP::Post.new(uri.request_uri)
    request.body = post_body.join
    request["Content-Type"] = "multipart/form-data; boundary=#{boundary}"
    
    # 添加必要的 headers（根据 curl 命令）
    request["X-UIM-device-id"] = "1"
    request["X-UIM-device-manufacturer"] = "1"
    request["X-UIM-device-brand"] = "1"
    request["X-UIM-device-model"] = "1"
    request["X-UIM-os-type"] = "1"
    request["X-UIM-os-version"] = "1"
    request["X-UIM-client-id"] = "1"
    request["X-UIM-client-version"] = "1"
    request["X-UIM-client-code"] = "1"
    
    begin
      response = http.request(request)
      
      if response.code == "200"
        JSON.parse(response.body)
      else
        UI.error("上传接口返回错误: #{response.code} - #{response.body}")
        nil
      end
    rescue => e
      UI.error("上传请求异常: #{e.message}")
      nil
    end
  end

  # 保存包关系方法
  def save_account_pkg_relation(params)
    # 请替换为您的实际保存接口 URL
    save_url = "https://sit-soc.uim-solution.com/cvn/app/save_account_pkg_relation"
    
    uri = URI.parse(save_url)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = (uri.scheme == 'https')
    
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json',
                                  'X-UIM-device-id' => '1',
                                  'X-UIM-device-manufacturer' => '1',
                                  'X-UIM-device-brand' => '1',
                                  'X-UIM-device-model' => '1',
                                  'X-UIM-os-type' => '1',
                                  'X-UIM-os-version' => '1',
                                  'X-UIM-client-id' => '1',
                                  'X-UIM-client-version' => '1',
                                  'X-UIM-client-code' => '1',
                                  'Cookie' => '1')
    request.body = {data: {
      account_id: params[:account_id],
      account_name: params[:account_name],
      pkg_id: params[:pkg_id],
      pkg_url: params[:pkg_url],
      pkg_version: params[:pkg_version],
      channel: params[:channel]
    }, echo: "111"}.to_json
    
    UI.message("保存关系请求体: #{request.body}")

    begin
      response = http.request(request)
      
      UI.message("保存关系接口返回: #{response.code} - #{response.body}")

      if response.code == "200"
        JSON.parse(response.body)
      else
        UI.error("保存关系接口返回错误: #{response.code} - #{response.body}")
        nil
      end
    rescue => e
      UI.error("保存关系请求异常: #{e.message}")
      nil
    end
  end
end
